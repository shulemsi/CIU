% Solve a Pattern Recognition Problem with a Neural Network
% Script generated by Neural Pattern Recognition app
% Created 18-Apr-2020 10:44:58
%
% This script assumes these variables are defined:
%
%   irisInputs - input data.
%   irisTargets - target data.

x = irisInputs;
t = irisTargets;
trainFcn = 'trainscg';  % Scaled conjugate gradient backpropagation.

% Create a Pattern Recognition Network
hiddenLayerSize = 10;
net = patternnet(hiddenLayerSize, trainFcn);

% Setup Division of Data for Training, Validation, Testing
net.divideParam.trainRatio = 70/100;
net.divideParam.valRatio = 15/100;
net.divideParam.testRatio = 15/100;

% Train the Network
[net,tr] = train(net,x,t);

%Test case input values
featuresinput=[4.32; 3.9; 6.8; 1.8];
%get predictions for the test case
featurestest=round((net(featuresinput)),1)';

class = max(featurestest);

prediction_index=find(class==featurestest);
predictions=round(featurestest*100);

names = ["Iris Setosa";
         "Iris Versicolor";
         "Iris Virginica"];

if class == featurestest(1)
    classname=names(1);
elseif class == featurestest(2)
    classname=names(2);
else
    classname=names(3);
end

% Feature Petal length random values tested
a1 = ((7.9-4.3).*rand(1000,1) + 4.3)';
a2 = ((2.0-4.4).*rand(1000,1) + 4.4)';
a3 = (1 + (6.9-1).*rand(1000,1))';
a4 = (0.1 + (2.5-0.1).*rand(1000,1))';

inputvalues=featuresinput(:)*ones(1,1000);
all=[a1; a2; a3; a4];
all(:,4)=featuresinput;
 

importancevalues=zeros(3,4);
utilityvalues=zeros(3,4);

for ii = 1:size(inputvalues,1)    %loop over 100 rows
    samples=inputvalues;
    samples(ii,:) = all(ii,:); %insert 10 random numbers
    predictionsfeature = round((net(samples)),1);
    
    cmin1=findmin(predictionsfeature');   
    cmax1=findmax(predictionsfeature');
    
    CI=(findCI(cmin1, cmax1))';
    importancevalues(:,ii)=CI;
   
    CU=(findCU(featurestest, cmin1, cmax1))';
    utilityvalues(:,ii)=CU;
end        

%Converting values to text
importancestr= string(zeros(size(importancevalues)));
for i = 1:numel(importancevalues)
    
    if (importancevalues(i) >= 0) && (importancevalues(i) < 0.25)
        importancestr(i)='not an important';
    elseif (importancevalues(i) >= 0.25) && (importancevalues(i) < 0.50)
        importancestr(i)='an important';
    elseif (importancevalues(i) >= 0.50) && (importancevalues(i) < 0.75)
        importancestr(i)='rather an important';
    else
        importancestr(i)='a highly important';
    end
end

utilitystr= string(zeros(size(utilityvalues)));
for j = 1:numel(utilityvalues)
    
    if (utilityvalues(j) >= 0) && (utilityvalues(j) < 0.25)
        utilitystr(j)='not a typical';
    elseif (utilityvalues(j) >= 0.25) && (utilityvalues(j) < 0.50)
        utilitystr(j)='an unlikely';
    elseif (utilityvalues(j) >= 0.50) && (utilityvalues(j) < 0.75)
        utilitystr(j)='a typical';
    else
        utilitystr(j)='a very typical';
    end
end

featuresname = ["petal length";
                "petal width";
                "sepal length";
                "sepal width"];

cprintf ('*Black','The model`s prediction is %d%% %s. Because;\n', predictions(prediction_index), classname);

text_explanations(prediction_index, importancevalues, utilityvalues, importancestr, utilitystr, featuresname);

%Contrastive predictions
contrastive_pre=predictions(1:end ~= prediction_index);
contrastive_names=names(1:end ~= prediction_index);
cont_find = ismember(predictions, contrastive_pre);
contras_prediction_index=find(cont_find);

for i = 1:numel(contrastive_pre)
    
cprintf ('*black','It is not %s (%d%%), because; \n', contrastive_names(i),contrastive_pre(i));
contrast_text_explanations(contras_prediction_index(i), importancevalues, ...
                           utilityvalues, importancestr, utilitystr, featuresname);
end

%Function to find cmin
function p = findmin(n)
    p =  min(n);
end

%Function to find cmax
function s = findmax(c)
    s =  max(c);
end

%CI and CU calculation
function calculateCI = findCI(mm, mx)
    calculateCI = (mx-mm)*100/100;
end

function calculateCU = findCU(n3, dymin, dymax)
d= dymax-dymin;
calculateCU= zeros(1,3);
for j = 1:numel(d)
if d(j) == 0
    calculateCU(j) = (n3(j)-dymin(j))./0.01;
else
    calculateCU(j) = (n3(j)-dymin(j))./d(j);
end

end
end
